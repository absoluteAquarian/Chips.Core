<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ output extension=".cs" #>
<# Type[] iTypes = new[]{
	typeof(SByte), typeof(Int16), typeof(Int32), typeof(Int64),
	typeof(Byte), typeof(UInt16), typeof(UInt32), typeof(UInt64)
}; #>
<# Type[] fTypes = new[]{
	typeof(Single), typeof(Double), typeof(Decimal)
}; #>
using Chips.Core.Meta;
using Chips.Core.Utility;

#pragma warning disable CS0162
namespace Chips.Core.Types.NumberProcessing{
<# foreach (var type in iTypes){ 
#>
	[TextTemplateGenerated]
	public struct <#= type.Name #>_T : INumber, IInteger{
		private <#= type.Name #> value;

		public object Value => value;

		public <#= type.Name #>_T(<#= type.Name #> value){
			this.value = value;
		}

<# if(type.Name != "Int32"){
#>
		public <#= type.Name #>_T(Int32 value){
			this.value = (<#= type.Name #>)value;
		}
<#
} #>

		public INumber Add(INumber number){
			//For sizes larger than int, this block should be removed by the compiler
			if(sizeof(<#= type.Name #>) < sizeof(int)){
				INumber upcast = ValueConverter.UpcastToAtLeastInt32(this);
				return upcast.Add(number);
			}

			if(TypeTracking.GetSizeFromNumericType(number.Value.GetType()) > sizeof(<#= type.Name #>))
				return number.Add(this);

			<#= type.Name #>_T convert = ValueConverter.CastTo<#= type.Name #>_T(number);
			return new <#= type.Name #>_T(value + convert.value);
		}

		public IInteger And(IInteger number){
			//For sizes larger than int, this block should be removed by the compiler
			if(sizeof(<#= type.Name #>) < sizeof(int)){
				INumber upcast = ValueConverter.UpcastToAtLeastInt32(this);
				return (upcast as IInteger)!.And(number);
			}

			if(number is not INumber iNum)
				throw new Exception("Internal Chips Error: IInteger instance was not an INumber");

			if(number is IFloat)
				throw new Exception("Cannot perform bitwise-AND operations with non-integer values");

			if(TypeTracking.GetSizeFromNumericType(iNum.Value.GetType()) > sizeof(<#= type.Name #>))
				return number.And(this);

			<#= type.Name #>_T convert = ValueConverter.CastTo<#= type.Name #>_T(iNum);
			return new <#= type.Name #>_T(value & convert.value);
		}

		public IInteger ArithmeticRotateLeft(){
			bool carry = Metadata.Flags.Carry;
			Metadata.Flags.Carry = unchecked(value & (<#= type.Name #>)((<#= type.Name #>)1 << (8 * sizeof(<#= type.Name #>) - 1))) != 0;
			
			var i = new <#= type.Name #>_T(value << 1);
			if(carry)
				i.value |= 1;

			return i;
		}

		public IInteger ArithmeticRotateRight(){
			bool carry = Metadata.Flags.Carry;
			Metadata.Flags.Carry = (value & 1) != 0;
			
			var i = new <#= type.Name #>_T(value >> 1);
			if(carry)
				i.value = (<#= type.Name #>)unchecked(i.value | ((<#= type.Name #>)1 << (8 * sizeof(<#= type.Name #>) - 1)));

			return i;
		}

		public IInteger ArithmeticShiftLeft()
			=> new <#= type.Name #>_T(value << 1);

		public IInteger ArithmeticShiftRight()
			=> new <#= type.Name #>_T(value >> 1);

		public INumber Divide(INumber number, bool inverseLogic = false){
			//For sizes larger than int, this block should be removed by the compiler
			if(sizeof(<#= type.Name #>) < sizeof(int)){
				INumber upcast = ValueConverter.UpcastToAtLeastInt32(this);
				return upcast.Divide(number);
			}

			if(TypeTracking.GetSizeFromNumericType(number.Value.GetType()) > sizeof(<#= type.Name #>))
				return number.Divide(this, true);

			<#= type.Name #>_T convert = ValueConverter.CastTo<#= type.Name #>_T(number);
			return new <#= type.Name #>_T(!inverseLogic ? value / convert.value : convert.value / value);
		}

		public IInteger GetBit(byte bit){
			if(bit >= 8 * sizeof(<#= type.Name #>))
				return new <#= type.Name #>_T(0);
			
			<#= type.Name #> mask = (<#= type.Name #>)(1 << bit);
			return new <#= type.Name #>_T(value & mask);
		}

		public INumber Multiply(INumber number){
			//For sizes larger than int, this block should be removed by the compiler
			if(sizeof(<#= type.Name #>) < sizeof(int)){
				INumber upcast = ValueConverter.UpcastToAtLeastInt32(this);
				return upcast.Multiply(number);
			}

			if(TypeTracking.GetSizeFromNumericType(number.Value.GetType()) > sizeof(<#= type.Name #>))
				return number.Multiply(this);

			<#= type.Name #>_T convert = ValueConverter.CastTo<#= type.Name #>_T(number);
			return new <#= type.Name #>_T(unchecked(value * convert.value));
		}

		public INumber Negate(){
<# if(!type.Name.StartsWith("U")){
#>
			//For sizes larger than int, this block should be removed by the compiler
			if(sizeof(<#= type.Name #>) < sizeof(int)){
				INumber upcast = ValueConverter.UpcastToAtLeastInt32(this);
				return upcast.Negate();
			}

			return new <#= type.Name #>_T(-value);
<# }else{
#>
			throw new InvalidOperationException("Negation cannot be performed on unsigned integers");
<#
} #>
		}

		public IInteger Not(){
			//For sizes larger than int, this block should be removed by the compiler
			if(sizeof(<#= type.Name #>) < sizeof(int)){
				INumber upcast = ValueConverter.UpcastToAtLeastInt32(this);
				return (upcast as IInteger)!.Not();
			}

			return new <#= type.Name #>_T(~value);
		}

		public IInteger Or(IInteger number){
			//For sizes larger than int, this block should be removed by the compiler
			if(sizeof(<#= type.Name #>) < sizeof(int)){
				INumber upcast = ValueConverter.UpcastToAtLeastInt32(this);
				return (upcast as IInteger)!.And(number);
			}

			if(number is not INumber iNum)
				throw new Exception("Internal Chips Error: IInteger instance was not an INumber");

			if(number is IFloat)
				throw new Exception("Cannot perform bitwise-OR operations with non-integer values");

			if(TypeTracking.GetSizeFromNumericType(iNum.Value.GetType()) > sizeof(<#= type.Name #>))
				return number.And(this);

			<#= type.Name #>_T convert = ValueConverter.CastTo<#= type.Name #>_T(iNum);
			return new <#= type.Name #>_T(value | convert.value);
		}

		public INumber Remainder(INumber number){
			//For sizes larger than int, this block should be removed by the compiler
			if(sizeof(<#= type.Name #>) < sizeof(int)){
				INumber upcast = ValueConverter.UpcastToAtLeastInt32(this);
				return upcast.Remainder(number);
			}

			if(TypeTracking.GetSizeFromNumericType(number.Value.GetType()) > sizeof(<#= type.Name #>))
				return number.Remainder(this);

			<#= type.Name #>_T convert = ValueConverter.CastTo<#= type.Name #>_T(number);
			return new <#= type.Name #>_T(value % convert.value);
		}

		public INumber Subtract(INumber number){
			//For sizes larger than int, this block should be removed by the compiler
			if(sizeof(<#= type.Name #>) < sizeof(int)){
				INumber upcast = ValueConverter.UpcastToAtLeastInt32(this);
				return upcast.Subtract(number);
			}

			if(TypeTracking.GetSizeFromNumericType(number.Value.GetType()) > sizeof(<#= type.Name #>))
				return number.Negate().Multiply(this.Negate());

			<#= type.Name #>_T convert = ValueConverter.CastTo<#= type.Name #>_T(number);
			return new <#= type.Name #>_T(unchecked(value - convert.value));
		}

		public IInteger Xor(IInteger number){
			//For sizes larger than int, this block should be removed by the compiler
			if(sizeof(<#= type.Name #>) < sizeof(int)){
				INumber upcast = ValueConverter.UpcastToAtLeastInt32(this);
				return (upcast as IInteger)!.And(number);
			}

			if(number is not INumber iNum)
				throw new Exception("Internal Chips Error: IInteger instance was not an INumber");

			if(number is IFloat)
				throw new Exception("Cannot perform bitwise-XOR operations with non-integer values");

			if(TypeTracking.GetSizeFromNumericType(iNum.Value.GetType()) > sizeof(<#= type.Name #>))
				return number.And(this);

			<#= type.Name #>_T convert = ValueConverter.CastTo<#= type.Name #>_T(iNum);
			return new <#= type.Name #>_T(value ^ convert.value);
		}
    }

<#
} #>
<# foreach (var type in fTypes){ 
#>
	[TextTemplateGenerated]
    public struct <#= type.Name #>_T : INumber, IFloat{
        private <#= type.Name #> value;

		public object Value => value;

		public <#= type.Name #>_T(<#= type.Name #> value){
			this.value = value;
		}

<# if(type.Name != "Single"){
#>
		public <#= type.Name #>_T(Single value){
			this.value = (<#= type.Name #>)value;
		}
<#
} #>

		public INumber Add(INumber number){
			int targetSize = TypeTracking.GetSizeFromNumericType(number.Value.GetType());

			if(number is IInteger || targetSize < sizeof(<#= type.Name #>))
				number = ValueConverter.CastTo<#= type.Name #>_T(number);
			else if(targetSize > sizeof(<#= type.Name #>))
				return number.Add(this);

			<#= type.Name #>_T convert = ValueConverter.CastTo<#= type.Name #>_T(number);
			return new <#= type.Name #>_T(value + convert.value);
		}

		public INumber Divide(INumber number, bool inverseLogic = false){
			int targetSize = TypeTracking.GetSizeFromNumericType(number.Value.GetType());

			if(number is IInteger || targetSize < sizeof(<#= type.Name #>))
				number = ValueConverter.CastTo<#= type.Name #>_T(number);
			else if(targetSize > sizeof(<#= type.Name #>))
				return number.Divide(this, true);

			<#= type.Name #>_T convert = ValueConverter.CastTo<#= type.Name #>_T(number);
			return new <#= type.Name #>_T(!inverseLogic ? value / convert.value : convert.value / value);
		}

		public IInteger GetBits()
<# if(type.Name == "Decimal"){
#>
			=> throw new InvalidOperationException("Retrieving the bits on an <f128> instance is not supported");
<# }else{
#>
			=> (ValueConverter.RetrieveFloatingPointBits(this) as IInteger)!;
<#
} #>

		public INumber Multiply(INumber number){
			int targetSize = TypeTracking.GetSizeFromNumericType(number.Value.GetType());

			if(number is IInteger || targetSize < sizeof(<#= type.Name #>))
				number = ValueConverter.CastTo<#= type.Name #>_T(number);
			else if(targetSize > sizeof(<#= type.Name #>))
				return number.Multiply(this);

			<#= type.Name #>_T convert = ValueConverter.CastTo<#= type.Name #>_T(number);
			return new <#= type.Name #>_T(value * convert.value);
		}

		public INumber Negate()
			=> new <#= type.Name #>_T(-value);

		public INumber Remainder(INumber number){
			int targetSize = TypeTracking.GetSizeFromNumericType(number.Value.GetType());

			if(number is IInteger || targetSize < sizeof(<#= type.Name #>))
				number = ValueConverter.CastTo<#= type.Name #>_T(number);
			else if(targetSize > sizeof(<#= type.Name #>))
				return number.Remainder(this);

			<#= type.Name #>_T convert = ValueConverter.CastTo<#= type.Name #>_T(number);
			return new <#= type.Name #>_T(value % convert.value);
		}

		public INumber Subtract(INumber number){
			int targetSize = TypeTracking.GetSizeFromNumericType(number.Value.GetType());

			if(number is IInteger || targetSize < sizeof(<#= type.Name #>))
				number = ValueConverter.CastTo<#= type.Name #>_T(number);
			else if(targetSize > sizeof(<#= type.Name #>))
				return number.Negate().Subtract(this.Negate());

			<#= type.Name #>_T convert = ValueConverter.CastTo<#= type.Name #>_T(number);
			return new <#= type.Name #>_T(value - convert.value);
		}
	}
	
<#
} #>
}